import { MatrixDataViewBuilder } from "../dataViewBuilder/matrixBuilder";
import { createCategoricalDataViewBuilder } from "./dataViewBuilder";
import isEmpty from "lodash-es/isEmpty";
import includes from "lodash-es/includes";
import uniq from "lodash-es/uniq";
import sum from "lodash-es/sum";
import map from "lodash-es/map";
import max from "lodash-es/max";
import sortBy from "lodash-es/sortBy";
import range from "lodash-es/range";
import clone from "lodash-es/clone";
import toArray from "lodash-es/toArray";
import groupBy from "lodash-es/groupBy";
import flatten from "lodash-es/flatten";
import take from "lodash-es/take";
import findIndex from "lodash-es/findIndex";
export class TestDataViewBuilder {
    constructor() {
        this.aggregateFunction = sum;
    }
    static createMatrixDataViewBuilder(table) {
        const tableMetadata = {
            name: "table"
        };
        return new MatrixDataViewBuilder(table, tableMetadata);
    }
    static setDefaultQueryName(source) {
        if (!source.queryName) {
            source.queryName = TestDataViewBuilder.DataViewName + "." + source.displayName;
        }
        return source;
    }
    static getDataViewBuilderColumnIdentitySources(options) {
        const optionsArray = (Array.isArray(options) ? options : [options]);
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        const fields = optionsArray.map(() => { }), optionsIdentityExpressions = optionsArray.map((opt) => opt.values);
        let identityExpressions = [];
        if (optionsIdentityExpressions.length > 1) {
            const identityExpressionsLength = optionsIdentityExpressions.length, identityExpressionsValuesLength = max(map(optionsIdentityExpressions, x => x.length));
            for (let vi = 0; vi < identityExpressionsValuesLength; vi++) {
                const current = optionsIdentityExpressions[0][vi];
                identityExpressions.push(current);
            }
        }
        else {
            identityExpressions = optionsIdentityExpressions[0];
        }
        return optionsArray.map((opt, i) => ({
            fields: fields,
            identities: identityExpressions
        }));
    }
    static getValuesTable(categories, values) {
        const columns = sortBy((categories || []).concat(values || []), x => x.source.index), maxLength = max(columns.map(x => x.values.length));
        return range(maxLength).map(i => columns.map(x => x.values[i]));
    }
    static createDataViewBuilderColumnOptions(categoriesColumns, valuesColumns, filter, customizeColumns) {
        const filterColumns = filter
            ? (options) => Array.isArray(options.values) && filter(options)
            : (options) => Array.isArray(options.values);
        const resultCategoriesColumns = isEmpty(categoriesColumns) ? [] : flatten(categoriesColumns).filter(filterColumns);
        const resultValuesColumns = isEmpty(valuesColumns) ? [] : flatten(valuesColumns).filter(filterColumns);
        const allColumns = (resultCategoriesColumns || []).concat(resultValuesColumns || []);
        allColumns.forEach((x, i) => x.source.index = i);
        if (customizeColumns) {
            allColumns.forEach((column) => customizeColumns(column.source));
        }
        allColumns.forEach((column) => {
            if (column.source.format) {
                const objects = column.source.objects = (column.source.objects || {});
                objects.general = objects.general || {};
                objects.general.formatString = objects.general.formatString || column.source.format;
            }
        });
        return {
            categories: resultCategoriesColumns.filter(x => !x.isGroup),
            grouped: resultCategoriesColumns.filter(x => x.isGroup),
            values: resultValuesColumns
        };
    }
    static setUpDataViewBuilderColumnOptions(options, aggregateFunction) {
        const resultOptions = clone(options);
        resultOptions.categories = resultOptions.categories && resultOptions.categories.map(x => clone(x));
        resultOptions.values = resultOptions.values && resultOptions.values.map(x => clone(x));
        resultOptions.grouped = resultOptions.grouped && resultOptions.grouped.map(x => clone(x));
        if (!isEmpty(options.categories)) {
            resultOptions.categories.forEach(x => x.source = TestDataViewBuilder.setDefaultQueryName(x.source));
            const allRows = TestDataViewBuilder.getValuesTable(options.categories, options.values);
            const categoriesLength = options.categories.length;
            const grouped = toArray(groupBy(allRows, x => take(x, categoriesLength)));
            resultOptions.categories.forEach((c, i) => c.values = grouped.map(x => x[0][i] === undefined ? null : x[0][i]));
            if (!isEmpty(options.values) && isEmpty(options.grouped)) { // Not completed for group categories
                resultOptions.values.forEach((c, i) => c.values = grouped.map(v => aggregateFunction(v.map(x => x[categoriesLength + i] || 0))));
            }
        }
        if (!isEmpty(options.values)) {
            resultOptions.values.forEach(x => x.source = TestDataViewBuilder.setDefaultQueryName(x.source));
        }
        if (!isEmpty(options.grouped)) {
            resultOptions.grouped.forEach(x => x.source = TestDataViewBuilder.setDefaultQueryName(x.source));
        }
        return resultOptions;
    }
    static setUpDataView(dataView, options) {
        if (!isEmpty(options.categories) && isEmpty(options.grouped)) {
            const category = dataView.categorical.categories[0];
            // Tree. (completed only for one category)
            dataView.tree = {
                root: {
                    childIdentityFields: category.identityFields,
                    children: category.values.map((value, index) => {
                        return {
                            values: [value],
                            name: value,
                            identity: category.identity && category.identity[index]
                        };
                    })
                }
            };
            // Table.
            dataView.table = {
                columns: dataView.categorical.categories.concat(dataView.categorical.values || []).map(x => x.source),
                identityFields: category.identityFields,
                rows: TestDataViewBuilder.getValuesTable(dataView.categorical.categories, dataView.categorical.values)
            };
            if (isEmpty(options.values)) {
                delete dataView.categorical.values;
            }
        }
        if (dataView.categorical.values) {
            const grouped = dataView.categorical.values.grouped();
            dataView.categorical.values.grouped = () => grouped;
        }
        return dataView;
    }
    createCategoricalDataViewBuilder(categoriesColumns, valuesColumns, columnNames, customizeColumns) {
        const builder = createCategoricalDataViewBuilder();
        const originalOptions = TestDataViewBuilder.createDataViewBuilderColumnOptions(categoriesColumns, valuesColumns, columnNames && (options => includes(columnNames, options.source.displayName)), customizeColumns);
        const options = TestDataViewBuilder.setUpDataViewBuilderColumnOptions(originalOptions, this.aggregateFunction);
        if (!isEmpty(options.categories)) {
            const identityFrom = TestDataViewBuilder.getDataViewBuilderColumnIdentitySources(options.categories);
            builder.withCategories(options.categories.map((category, i) => ({
                source: category.source,
                values: category.values,
                objects: category.objects,
                identity: identityFrom[i].identities,
                identityFields: identityFrom[i].fields
            })));
        }
        if (!isEmpty(options.grouped)) {
            const groupedCategory = options.grouped[0]; // Finished only for one category.
            const categoryValues = originalOptions.categories
                && originalOptions.categories[0]
                && originalOptions.categories[0].values
                || [];
            const uniqueCategoryValues = uniq(categoryValues) || [undefined], uniqueGroupedValues = uniq(groupedCategory.values);
            builder.withGroupedValues({
                groupColumn: {
                    source: groupedCategory.source,
                    values: uniqueGroupedValues,
                    identityFrom: TestDataViewBuilder.getDataViewBuilderColumnIdentitySources(groupedCategory)[0]
                },
                valueColumns: options.values.map(x => ({ source: x.source })),
                data: uniqueGroupedValues.map(groupedValue => options.values.map((column, columnIndex) => ({
                    values: column.values && uniqueCategoryValues
                        .map(categoryValue => {
                        const index = findIndex(range(categoryValues.length), i => categoryValues[i] === categoryValue && groupedCategory.values[i] === groupedValue);
                        return column.values[index] === undefined ? null : column.values[index];
                    }),
                    highlights: column.highlights,
                    minLocal: column.minLocal,
                    maxLocal: column.maxLocal
                })))
            });
        }
        else if (!isEmpty(options.values)) {
            builder.withValues({ columns: options.values });
        }
        const builderBuild = builder.build.bind(builder);
        builder.build = () => {
            return TestDataViewBuilder.setUpDataView(builderBuild(), options);
        };
        return builder;
    }
}
TestDataViewBuilder.DataViewName = "Data";
//# sourceMappingURL=testDataViewBuilder.js.map